Jan-06-2023 14:16:32 [error] {"message":"text error"}
Jan-06-2023 14:17:41 [error] {"message":"text error"}
Jan-06-2023 14:27:35 [error] {"message":"text error"}
<<<<<<< HEAD
Jan-06-2023 15:47:39 [error] {"message":"text error"}
Jan-09-2023 14:59:07 [error] {"message":"text error"}
=======
>>>>>>> features/yatin/seller
Jan-06-2023 17:24:18 [error] {"message":"text error"}
Jan-06-2023 17:27:09 [error] {"message":"text error"}
Jan-06-2023 17:28:46 [error] {"message":"text error"}
Jan-06-2023 17:53:29 [error] {"message":"text error"}
Jan-07-2023 11:19:12 [error] {"message":"text error"}
Jan-07-2023 11:38:16 [error] {"message":"text error"}
Jan-07-2023 11:39:06 [error] {"message":"text error"}
Jan-07-2023 11:48:57 [error] {"message":"text error"}
Jan-07-2023 11:50:29 [error] {"message":"text error"}
Jan-07-2023 11:51:51 [error] {"message":"text error"}
Jan-07-2023 11:53:52 [error] {"message":"text error"}
Jan-07-2023 11:58:25 [error] {"message":"text error"}
Jan-07-2023 12:00:41 [error] {"message":"text error"}
Jan-07-2023 21:23:54 [error] {"message":"text error"}
Jan-07-2023 21:24:42 [error] {"message":"text error"}
Jan-07-2023 21:26:17 [error] {"message":"text error"}
Jan-07-2023 21:29:08 [error] {"message":"text error"}
Jan-07-2023 21:47:11 [error] {"message":"text error"}
Jan-07-2023 21:49:12 [error] {"message":"text error"}
Jan-07-2023 21:50:48 [error] {"message":"text error"}
Jan-08-2023 19:36:44 [error] {"message":"text error"}
Jan-08-2023 19:46:28 [error] {"message":"text error"}
Jan-08-2023 20:54:34 [error] {"message":"text error"}
Jan-08-2023 20:58:15 [error] {"message":"text error"}
Jan-08-2023 20:58:58 [error] {"message":"text error"}
Jan-08-2023 21:00:02 [error] {"message":"text error"}
Jan-08-2023 21:06:15 [error] {"message":"text error"}
Jan-08-2023 21:07:38 [error] {"message":"text error"}
Jan-08-2023 21:08:26 [error] {"message":"text error"}
Jan-08-2023 21:09:44 [error] {"message":"text error"}
Jan-08-2023 21:20:18 [error] {"message":"text error"}
Jan-08-2023 21:21:22 [error] {"message":"text error"}
Jan-08-2023 21:23:25 [error] {"message":"text error"}
Jan-08-2023 21:25:45 [error] {"message":"text error"}
Jan-08-2023 21:38:53 [error] {"message":"text error"}
Jan-08-2023 21:41:55 [error] {"message":"text error"}
Jan-08-2023 21:44:01 [error] {"message":"text error"}
Jan-08-2023 21:59:39 [error] {"message":"text error"}
Jan-08-2023 22:00:43 [error] {"message":"text error"}
Jan-08-2023 22:01:15 [error] {"message":"text error"}
Jan-08-2023 22:01:44 [error] {"message":"text error"}
Jan-08-2023 22:02:21 [error] {"message":"text error"}
Jan-08-2023 22:02:40 [error] {"message":"text error"}
Jan-08-2023 22:04:25 [error] {"message":"text error"}
Jan-08-2023 22:24:30 [error] {"message":"text error"}
Jan-08-2023 22:33:41 [error] {"message":"text error"}
Jan-08-2023 22:36:29 [error] {"message":"text error"}
Jan-08-2023 22:37:57 [error] {"message":"text error"}
Jan-08-2023 22:40:23 [error] {"message":"text error"}
Jan-08-2023 22:55:33 [error] {"message":"text error"}
Jan-08-2023 22:56:01 [error] {"message":"text error"}
Jan-08-2023 22:57:31 [error] {"message":"text error"}
Jan-08-2023 22:58:58 [error] {"message":"text error"}
Jan-08-2023 23:01:27 [error] {"message":"text error"}
Jan-08-2023 23:04:21 [error] {"message":"text error"}
Jan-08-2023 23:06:28 [error] {"message":"text error"}
Jan-08-2023 23:09:11 [error] {"message":"text error"}
Jan-08-2023 23:13:01 [error] {"message":"text error"}
Jan-08-2023 23:14:07 [error] {"message":"text error"}
Jan-08-2023 23:18:24 [error] {"message":"text error"}
Jan-08-2023 23:18:55 [error] {"message":"text error"}
Jan-09-2023 00:19:05 [error] {"message":"text error"}
Jan-09-2023 00:23:48 [error] {"message":"text error"}
Jan-09-2023 00:33:08 [error] {"message":"text error"}
Jan-09-2023 00:44:55 [error] {"message":"text error"}
Jan-09-2023 00:46:21 [error] {"message":"text error"}
Jan-09-2023 00:47:22 [error] {"message":"text error"}
Jan-09-2023 00:48:15 [error] {"message":"text error"}
Jan-09-2023 00:49:34 [error] {"message":"text error"}
Jan-09-2023 00:50:23 [error] {"message":"text error"}
Jan-09-2023 00:58:03 [error] {"message":"text error"}
Jan-09-2023 01:01:56 [error] {"message":"text error"}
Jan-09-2023 01:04:06 [error] {"message":"text error"}
Jan-09-2023 01:07:49 [error] {"message":"text error"}
Jan-09-2023 01:08:36 [error] {"message":"text error"}
Jan-09-2023 01:51:31 [error] {"message":"text error"}
Jan-09-2023 11:20:28 [error] {"message":"text error"}
Jan-09-2023 17:26:10 [error] {"message":"text error"}
Jan-09-2023 17:29:19 [error] {"message":"text error"}
Jan-09-2023 17:34:45 [error] {"message":"text error"}
Jan-09-2023 17:36:29 [error] {"message":"text error"}
Jan-09-2023 17:40:23 [error] {"message":"text error"}
Jan-09-2023 17:41:53 [error] {"message":"text error"}
Jan-09-2023 17:44:56 [error] {"message":"text error"}
Jan-09-2023 17:50:06 [error] {"message":"text error"}
Jan-09-2023 17:52:01 [error] {"message":"text error"}
Jan-09-2023 17:53:53 [error] {"message":"text error"}
Jan-09-2023 17:54:42 [error] {"message":"text error"}
Jan-09-2023 17:56:15 [error] {"message":"text error"}
Jan-09-2023 17:56:43 [error] {"message":"text error"}
Jan-09-2023 17:57:22 [error] {"message":"text error"}
Jan-09-2023 18:01:13 [error] {"message":"text error"}
Jan-09-2023 18:02:26 [error] {"message":"text error"}
Jan-09-2023 18:04:18 [error] {"message":"text error"}
Jan-09-2023 18:05:28 [error] {"message":"text error"}
Jan-09-2023 18:06:06 [error] {"message":"text error"}
Jan-09-2023 18:09:22 [error] {"message":"text error"}
Jan-09-2023 18:11:22 [error] {"message":"text error"}
Jan-09-2023 18:11:56 [error] {"message":"text error"}
Jan-09-2023 18:13:31 [error] {"message":"text error"}
Jan-09-2023 18:16:21 [error] {"message":"text error"}
Jan-09-2023 18:16:23 [error] {"message":"text error"}
Jan-09-2023 18:16:34 [error] {"message":"text error"}
Jan-10-2023 09:59:51 [error] {"message":"text error"}
Jan-10-2023 10:07:27 [error] {"message":"text error"}
Jan-10-2023 10:13:38 [error] {"message":"text error"}
Jan-10-2023 10:15:10 [error] {"message":"text error"}
Jan-10-2023 10:16:43 [error] {"message":"text error"}
Jan-10-2023 10:19:05 [error] {"message":"text error"}
Jan-10-2023 10:22:31 [error] {"message":"text error"}
Jan-10-2023 10:24:30 [error] {"message":"text error"}
Jan-10-2023 10:25:56 [error] {"message":"text error"}
Jan-10-2023 10:28:08 [error] {"message":"text error"}
Jan-10-2023 10:28:54 [error] {"message":"text error"}
Jan-10-2023 10:29:48 [error] {"message":"text error"}
Jan-10-2023 10:30:19 [error] {"message":"text error"}
Jan-10-2023 10:32:13 [error] {"message":"text error"}
Jan-10-2023 10:44:00 [error] {"message":"text error"}
Jan-10-2023 10:51:51 [error] {"message":"text error"}
Jan-10-2023 10:54:17 [error] {"message":"text error"}
Jan-10-2023 11:00:59 [error] {"message":"text error"}
Jan-10-2023 11:02:32 [error] {"message":"text error"}
Jan-10-2023 11:12:06 [error] {"message":"text error"}
Jan-10-2023 11:14:41 [error] {"message":"text error"}
Jan-10-2023 11:19:00 [error] {"message":"text error"}
Jan-10-2023 11:20:05 [error] {"message":"text error"}
Jan-10-2023 11:20:28 [error] {"message":"text error"}
Jan-10-2023 11:21:53 [error] {"message":"text error"}
Jan-10-2023 11:29:11 [error] {"message":"text error"}
Jan-10-2023 11:32:02 [error] {"message":"text error"}
Jan-10-2023 11:34:30 [error] {"message":"text error"}
Jan-10-2023 11:37:57 [error] {"message":"text error"}
<<<<<<< HEAD
=======
Jan-06-2023 15:47:39 [error] {"message":"text error"}
Jan-09-2023 14:59:07 [error] {"message":"text error"}
>>>>>>> features/yatin/seller
<<<<<<< HEAD
Jan-16-2023 11:59:56 [error] {"message":"400 - Unexpected token } in JSON at position 46"}
Jan-16-2023 11:59:56 [error] {"message":"400 - Unexpected token } in JSON at position 46"}
Jan-16-2023 17:51:45 [error] {"message":"Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: data and hash arguments required}"}
Jan-16-2023 17:53:07 [error] {"message":"Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: data and hash arguments required}"}
Jan-16-2023 17:53:38 [error] {"message":"Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: data and hash arguments required}"}
Jan-16-2023 17:55:33 [error] {"message":"Error: {reference: Anonymous, message: Invalid Body!, errorCode: 500, errors: [], error: Invalid Body!}"}
Jan-16-2023 17:56:25 [error] {"message":"Error: {reference: Anonymous, message: Invalid Body!, errorCode: 500, errors: [], error: Invalid Body!}"}
Jan-16-2023 17:56:50 [error] {"message":"Error: {reference: validationMiddleware, message: \"password\" is required, errorCode: 412, errors: [], error: \"password\" is required}"}
Jan-16-2023 17:57:25 [error] {"message":"Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: Unexpected token i in JSON at position 11}"}
Jan-16-2023 17:57:36 [error] {"message":"Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: Unexpected token i in JSON at position 11}"}
Jan-16-2023 17:57:53 [error] {"message":"Error: {reference: validationMiddleware, message: \"password\" is required, errorCode: 412, errors: [], error: \"password\" is required}"}
Jan-16-2023 17:58:58 [error] {"message":"Error: {reference: validationMiddleware, message: password is required, errorCode: 412, errors: [], error: password is required}"}
Jan-16-2023 18:00:16 [error] {"message":"Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: data and hash arguments required}"}
Jan-16-2023 18:19:22 [error] {"message":"Error: {reference: POST /sellers/signin, message: Server Error!, errorCode: 500, errors: [], error: Seller.findOne is not a function}"}
Jan-16-2023 18:29:49 [error] {"message":"Error: {reference: POST /sellers/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-16-2023 18:30:56 [error] {"message":"Error: {reference: POST/seller/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-16-2023 18:31:53 [error] {"message":"Error: {reference: POST/seller/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-16-2023 18:34:40 [error] {"message":"Error: {reference: POST/seller/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-16-2023 18:39:48 [error] {"message":"Error: {reference: POST/seller/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-16-2023 18:40:49 [error] {"message":"Error: {reference: POST/seller/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-16-2023 18:41:25 [error] {"message":"Error: {reference: POST/seller/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-17-2023 10:51:19 [error] {"message":"Error: {reference: POST/seller/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-17-2023 10:57:57 [error] {"message":"Error: {reference: POST/seller/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-17-2023 10:58:15 [error] {"message":"Error: {reference: POST/seller/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-17-2023 11:01:29 [error] {"message":"Error: {reference: POST/seller/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-17-2023 11:01:55 [error] {"message":"Error: {reference: POST/seller/signin, message: Server Error!, errorCode: 500, errors: [], error: AppError is not a constructor}"}
Jan-17-2023 11:03:06 [error] {"message":"Error: {reference: signin, message: Server Error!, errorCode: 404, errors: [], error: Seller not found}"}
Jan-17-2023 11:06:19 [error] {"message":"Error: {reference: signin, message: Server Error!, errorCode: 404, errors: [], error: Seller not found}"}
Jan-17-2023 11:08:19 [error] {"message":"Error: {reference: signin, message: Seller not found, errorCode: 404, errors: [], error: Seller not found}"}
Jan-17-2023 11:13:01 [error] {"message":"Error: {reference: signin, message: Seller not found, errorCode: 404, errors: [], error: Seller not found}"}
Jan-17-2023 11:14:28 [error] {"message":"Error: {reference: validationMiddleware, message: email is required, errorCode: 412, errors: [], error: email is required}"}
Jan-17-2023 11:14:38 [error] {"message":"Error: {reference: validationMiddleware, message: email is required, errorCode: 412, errors: [], error: email is required}"}
Jan-17-2023 11:18:40 [error] {"message":"Error: {reference: validationMiddleware, message: password is required, errorCode: 412, errors: [], error: password is required}"}
Jan-17-2023 11:56:18 [error] {"message":"Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: validator is not a function}"}
Jan-17-2023 11:57:07 [error] {"message":"Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: validator is not a function}"}
Jan-17-2023 11:58:26 [error] {"message":"Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: validator is not a function}"}
Jan-17-2023 12:01:13 [error] {"message":"Error: {reference: validationMiddleware, message: name is required, errorCode: 412, errors: [], error: name is required}"}
Jan-17-2023 12:18:11 [error] {"message":"Error: {reference: validationMiddleware, message: name is required, errorCode: 412, errors: [], error: name is required}"}
Jan-17-2023 12:18:25 [error] {"message":"Error: {reference: validationMiddleware, message: email must be a valid email, errorCode: 412, errors: [], error: email must be a valid email}"}
Jan-17-2023 12:18:33 [error] {"message":"Error: {reference: POST /seller/signup, message: Server Error!, errorCode: 500, errors: [], error: email is not defined}"}
Jan-17-2023 12:18:42 [error] {"message":"Error: {reference: POST /seller/signup, message: Server Error!, errorCode: 500, errors: [], error: email is not defined}"}
Jan-17-2023 12:20:03 [error] {"message":"Error: {reference: POST /seller/signup, message: Server Error!, errorCode: 500, errors: [], error: Seller is not defined}"}
Jan-17-2023 12:20:42 [error] {"message":"Error: {reference: POST /seller/signup, message: Server Error!, errorCode: 500, errors: [], error: Cannot read properties of undefined (reading 'create')}"}
Jan-17-2023 12:21:18 [error] {"message":"Error: {reference: POST /seller/signup, message: Server Error!, errorCode: 500, errors: [], error: Cannot read properties of undefined (reading 'create')}"}
Jan-17-2023 12:23:49 [error] {"message":"Error: {reference: POST /seller/signup, message: Server Error!, errorCode: 500, errors: [], error: Cannot read properties of undefined (reading 'create')}"}
Jan-17-2023 12:25:20 [error] {"message":"Error: {reference: POST /seller/signup, message: Server Error!, errorCode: 500, errors: [], error: Seller.findOne is not a function}"}
Jan-17-2023 12:27:24 [error] {"message":"Error: {reference: POST /seller/signup, message: Server Error!, errorCode: 500, errors: [], error: Seller.findOne is not a function}"}
Jan-17-2023 12:28:03 [error] {"message":"Error: {reference: POST /seller/signup, message: Server Error!, errorCode: 500, errors: [], error: Seller.findOne is not a function}"}
Jan-17-2023 12:33:05 [error] {"message":"Error: {reference: POST /seller/signup, message: Server Error!, errorCode: 500, errors: [], error: Parameter \"filter\" to findOne() must be an object, got yatinnarula99915@gmail.com}"}
Jan-17-2023 12:36:12 [error] {"message":"Error: {reference: signup, message: Seller already exists, errorCode: 409, errors: [], error: Seller already exists}"}
Jan-17-2023 12:36:21 [error] {"message":"Error: {reference: validationMiddleware, message: email is required, errorCode: 412, errors: [], error: email is required}"}
Jan-17-2023 12:36:36 [error] {"message":"Error: {reference: POST /seller/signup, message: Duplicate Key Violates unique constraint, errorCode: 412, errors: [], error: E11000 duplicate key error collection: ecommerce.sellers index: mobile_1 dup key: { mobile: 7678277878.0 }}"}
Jan-17-2023 12:40:21 [error] {"message":"Error: {reference: validationMiddleware, message: otp is required, errorCode: 412, errors: [], error: otp is required}"}
Jan-17-2023 12:40:32 [error] {"message":"Error: {reference: validationMiddleware, message: email must be a valid email, errorCode: 412, errors: [], error: email must be a valid email}"}
Jan-17-2023 12:46:54 [error] {"message":"Error: {reference: async (req, res,next) => {\r\n  try{\r\n    const reference = verifyOtp;\r\n  let { email, otp } = req.body;\r\n  const verifyingOtp = await OtpSeller.findOne({ email });\r\n  if (!verifyingOtp || !util.compareHash(otp, verifyingOtp.otp)) {\r\n    throw new AppError(reference, \"Incorrect Otp\", 400)\r\n  }\r\n  await Seller.findOneAndUpdate(\r\n    { email: { $gte: email } },\r\n    { isVerified: true }\r\n  );\r\n  await OtpSeller.findOneAndDelete({ email: { $gte: email } });\r\n  res.send(\"User Verified\");\r\n  }catch (error) {\r\n    error.reference = error.reference ? error.reference : \"POST /seller/verifyOtp\";\r\n    next(error);\r\n  }\r\n}, message: Incorrect Otp, errorCode: 400, errors: [], error: Incorrect Otp}"}
Jan-17-2023 12:47:01 [error] {"message":"Error: {reference: async (req, res,next) => {\r\n  try{\r\n    const reference = verifyOtp;\r\n  let { email, otp } = req.body;\r\n  const verifyingOtp = await OtpSeller.findOne({ email });\r\n  if (!verifyingOtp || !util.compareHash(otp, verifyingOtp.otp)) {\r\n    throw new AppError(reference, \"Incorrect Otp\", 400)\r\n  }\r\n  await Seller.findOneAndUpdate(\r\n    { email: { $gte: email } },\r\n    { isVerified: true }\r\n  );\r\n  await OtpSeller.findOneAndDelete({ email: { $gte: email } });\r\n  res.send(\"User Verified\");\r\n  }catch (error) {\r\n    error.reference = error.reference ? error.reference : \"POST /seller/verifyOtp\";\r\n    next(error);\r\n  }\r\n}, message: Incorrect Otp, errorCode: 400, errors: [], error: Incorrect Otp}"}
Jan-17-2023 12:47:07 [error] {"message":"Error: {reference: async (req, res,next) => {\r\n  try{\r\n    const reference = verifyOtp;\r\n  let { email, otp } = req.body;\r\n  const verifyingOtp = await OtpSeller.findOne({ email });\r\n  if (!verifyingOtp || !util.compareHash(otp, verifyingOtp.otp)) {\r\n    throw new AppError(reference, \"Incorrect Otp\", 400)\r\n  }\r\n  await Seller.findOneAndUpdate(\r\n    { email: { $gte: email } },\r\n    { isVerified: true }\r\n  );\r\n  await OtpSeller.findOneAndDelete({ email: { $gte: email } });\r\n  res.send(\"User Verified\");\r\n  }catch (error) {\r\n    error.reference = error.reference ? error.reference : \"POST /seller/verifyOtp\";\r\n    next(error);\r\n  }\r\n}, message: Incorrect Otp, errorCode: 400, errors: [], error: Incorrect Otp}"}
Jan-17-2023 12:47:24 [error] {"message":"Error: {reference: signup, message: Seller already exists, errorCode: 409, errors: [], error: Seller already exists}"}
Jan-17-2023 12:47:28 [error] {"message":"Error: {reference: async (req, res,next) => {\r\n  try{\r\n    const reference = verifyOtp;\r\n  let { email, otp } = req.body;\r\n  const verifyingOtp = await OtpSeller.findOne({ email });\r\n  if (!verifyingOtp || !util.compareHash(otp, verifyingOtp.otp)) {\r\n    throw new AppError(reference, \"Incorrect Otp\", 400)\r\n  }\r\n  await Seller.findOneAndUpdate(\r\n    { email: { $gte: email } },\r\n    { isVerified: true }\r\n  );\r\n  await OtpSeller.findOneAndDelete({ email: { $gte: email } });\r\n  res.send(\"User Verified\");\r\n  }catch (error) {\r\n    error.reference = error.reference ? error.reference : \"POST /seller/verifyOtp\";\r\n    next(error);\r\n  }\r\n}, message: Incorrect Otp, errorCode: 400, errors: [], error: Incorrect Otp}"}
Jan-17-2023 12:47:50 [error] {"message":"Error: {reference: verifyOtp, message: Incorrect Otp, errorCode: 400, errors: [], error: Incorrect Otp}"}
Jan-17-2023 12:48:56 [error] {"message":"Error: {reference: POST /seller/verifyOtp, message: Server Error!, errorCode: 500, errors: [], error: Cannot read properties of null (reading 'otp')}"}
Jan-17-2023 12:50:00 [error] {"message":"Error: {reference: POST /seller/verifyOtp, message: Server Error!, errorCode: 500, errors: [], error: Cannot read properties of null (reading 'otp')}"}
Jan-17-2023 12:50:31 [error] {"message":"Error: {reference: POST /seller/verifyOtp, message: Server Error!, errorCode: 500, errors: [], error: Cannot read properties of null (reading 'otp')}"}
Jan-17-2023 12:51:42 [error] {"message":"Error: {reference: verifyOtp, message: Incorrect Otp, errorCode: 400, errors: [], error: Incorrect Otp}"}
Jan-17-2023 12:53:10 [error] {"message":"Error: {reference: verifyOtp, message: Incorrect Otp, errorCode: 400, errors: [], error: Incorrect Otp}"}
Jan-17-2023 12:54:54 [error] {"message":"Error: {reference: validationMiddleware, message: newPassword is required, errorCode: 412, errors: [], error: newPassword is required}"}
Jan-17-2023 12:55:06 [error] {"message":"Error: {reference: validationMiddleware, message: currentPassword is required, errorCode: 412, errors: [], error: currentPassword is required}"}
Jan-17-2023 12:55:20 [error] {"message":"Error: {reference: validationMiddleware, message: email must be a valid email, errorCode: 412, errors: [], error: email must be a valid email}"}
Jan-17-2023 12:55:30 [error] {"message":"Error: {reference: changePassword, message: Current and new Password same, errorCode: 400, errors: [], error: Current and new Password same}"}
Jan-17-2023 12:57:56 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 12:58:18 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 12:59:13 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:00:20 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:06:26 [error] {"message":"Error: {reference: validationMiddleware, message: newPassword length must be at least 6 characters long, errorCode: 412, errors: [], error: newPassword length must be at least 6 characters long}"}
Jan-17-2023 13:06:44 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:15:43 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:15:58 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:16:00 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:16:08 [error] {"message":"Error: {reference: validationMiddleware, message: currentPassword is required, errorCode: 412, errors: [], error: currentPassword is required}"}
Jan-17-2023 13:16:14 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:16:16 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:17:04 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:17:20 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:17:26 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:17:39 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:17:46 [error] {"message":"Error: {reference: changePassword, message: Current and new Password same, errorCode: 400, errors: [], error: Current and new Password same}"}
Jan-17-2023 13:17:51 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:18:00 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:18:15 [error] {"message":"Error: {reference: changePassword, message: Seller not found, errorCode: 404, errors: [], error: Seller not found}"}
Jan-17-2023 13:19:38 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:19:55 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:20:42 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:29:06 [error] {"message":"Error: {reference: validationMiddleware, message: name is required, errorCode: 412, errors: [], error: name is required}"}
Jan-17-2023 13:29:46 [error] {"message":"Error: {reference: verifyOtp, message: Incorrect Otp, errorCode: 400, errors: [], error: Incorrect Otp}"}
Jan-17-2023 13:29:54 [error] {"message":"Error: {reference: validationMiddleware, message: otp is required, errorCode: 412, errors: [], error: otp is required}"}
Jan-17-2023 13:30:15 [error] {"message":"Error: {reference: validationMiddleware, message: password is required, errorCode: 412, errors: [], error: password is required}"}
Jan-17-2023 13:31:14 [error] {"message":"Error: {reference: validationMiddleware, message: email is required, errorCode: 412, errors: [], error: email is required}"}
Jan-17-2023 13:31:25 [error] {"message":"Error: {reference: changePassword, message: Current and new Password same, errorCode: 400, errors: [], error: Current and new Password same}"}
Jan-17-2023 13:31:37 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:32:08 [error] {"message":"Error: {reference: validationMiddleware, message: email is required, errorCode: 412, errors: [], error: email is required}"}
Jan-17-2023 13:32:47 [error] {"message":"Error: {reference: validationMiddleware, message: newPassword is required, errorCode: 412, errors: [], error: newPassword is required}"}
Jan-17-2023 13:33:12 [error] {"message":"Error: {reference: async (req, res, next) => {\r\n  try{\r\n    const reference = verifyChangedOtp;\r\n  let { email, otp, newPassword } = req.body;\r\n  const verifyingOtp = await OtpSeller.findOne({ email });\r\n    if (!verifyingOtp || !util.compareHash(otp, verifyingOtp.otp)) {\r\n      throw new AppError(reference, \"Incorrect Otp\", 400);\r\n    }\r\n  const hash = await bcrypt.hash(newPassword, 10);\r\n  await Seller.findOneAndUpdate({ email: { $gte: email } }, { password: hash });\r\n  await OtpSeller.findOneAndDelete({ email: { $gte: email } });\r\n  res.send(\"Password Updated\");\r\n}catch (error) {\r\n  error.reference = error.reference ? error.reference : \"POST /seller/verifyChangedOtp\";\r\n  next(error);\r\n}\r\n}, message: Incorrect Otp, errorCode: 400, errors: [], error: Incorrect Otp}"}
Jan-17-2023 13:33:42 [error] {"message":"Error: {reference: async (req, res, next) => {\r\n  try{\r\n    const reference = verifyChangedOtp;\r\n  let { email, otp, newPassword } = req.body;\r\n  const verifyingOtp = await OtpSeller.findOne({ email });\r\n    if (!verifyingOtp || !util.compareHash(otp, verifyingOtp.otp)) {\r\n      throw new AppError(reference, \"Incorrect Otp\", 400);\r\n    }\r\n  const hash = await bcrypt.hash(newPassword, 10);\r\n  await Seller.findOneAndUpdate({ email: { $gte: email } }, { password: hash });\r\n  await OtpSeller.findOneAndDelete({ email: { $gte: email } });\r\n  res.send(\"Password Updated\");\r\n}catch (error) {\r\n  error.reference = error.reference ? error.reference : \"POST /seller/verifyChangedOtp\";\r\n  next(error);\r\n}\r\n}, message: Incorrect Otp, errorCode: 400, errors: [], error: Incorrect Otp}"}
Jan-17-2023 13:34:03 [error] {"message":"Error: {reference: async (req, res, next) => {\r\n  try{\r\n    const reference = verifyChangedOtp;\r\n  let { email, otp, newPassword } = req.body;\r\n  const verifyingOtp = await OtpSeller.findOne({ email });\r\n    if (!verifyingOtp || !util.compareHash(otp, verifyingOtp.otp)) {\r\n      throw new AppError(reference, \"Incorrect Otp or Bad request\", 400);\r\n    }\r\n  const hash = await bcrypt.hash(newPassword, 10);\r\n  await Seller.findOneAndUpdate({ email: { $gte: email } }, { password: hash });\r\n  await OtpSeller.findOneAndDelete({ email: { $gte: email } });\r\n  res.send(\"Password Updated\");\r\n}catch (error) {\r\n  error.reference = error.reference ? error.reference : \"POST /seller/verifyChangedOtp\";\r\n  next(error);\r\n}\r\n}, message: Incorrect Otp or Bad request, errorCode: 400, errors: [], error: Incorrect Otp or Bad request}"}
Jan-17-2023 13:34:39 [error] {"message":"Error: {reference: signin, message: Password incorrect, errorCode: 401, errors: [], error: Password incorrect}"}
Jan-17-2023 13:40:30 [error] {"message":"Error: {reference: validationMiddleware, message: name is required, errorCode: 412, errors: [], error: name is required}"}
Jan-17-2023 13:40:56 [error] {"message":"Error: {reference: verifyOtp, message: Incorrect Otp, errorCode: 400, errors: [], error: Incorrect Otp}"}
Jan-17-2023 13:41:08 [error] {"message":"Error: {reference: validationMiddleware, message: email is required, errorCode: 412, errors: [], error: email is required}"}
Jan-17-2023 13:41:28 [error] {"message":"Error: {reference: validationMiddleware, message: email is required, errorCode: 412, errors: [], error: email is required}"}
Jan-17-2023 13:41:34 [error] {"message":"Error: {reference: signin, message: Password incorrect, errorCode: 401, errors: [], error: Password incorrect}"}
Jan-17-2023 13:41:53 [error] {"message":"Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect}"}
Jan-17-2023 13:42:00 [error] {"message":"Error: {reference: changePassword, message: Current and new Password same, errorCode: 400, errors: [], error: Current and new Password same}"}
Jan-17-2023 13:42:08 [error] {"message":"Error: {reference: validationMiddleware, message: email is required, errorCode: 412, errors: [], error: email is required}"}
Jan-17-2023 13:42:28 [error] {"message":"Error: {reference: validationMiddleware, message: email is required, errorCode: 412, errors: [], error: email is required}"}
Jan-17-2023 13:42:46 [error] {"message":"Error: {reference: async (req, res, next) => {\r\n  try{\r\n    const reference = verifyChangedOtp;\r\n  let { email, otp, newPassword } = req.body;\r\n  const verifyingOtp = await OtpSeller.findOne({ email });\r\n    if (!verifyingOtp || !util.compareHash(otp, verifyingOtp.otp)) {\r\n      throw new AppError(reference, \"Incorrect Otp or Bad request\", 400);\r\n    }\r\n  const hash = await bcrypt.hash(newPassword, 10);\r\n  await Seller.findOneAndUpdate({ email: { $gte: email } }, { password: hash });\r\n  await OtpSeller.findOneAndDelete({ email: { $gte: email } });\r\n  res.send(\"Password Updated\");\r\n}catch (error) {\r\n  error.reference = error.reference ? error.reference : \"POST /seller/verifyChangedOtp\";\r\n  next(error);\r\n}\r\n}, message: Incorrect Otp or Bad request, errorCode: 400, errors: [], error: Incorrect Otp or Bad request}"}
Jan-17-2023 13:42:51 [error] {"message":"Error: {reference: validationMiddleware, message: email is required, errorCode: 412, errors: [], error: email is required}"}
=======
Jan-13-2023 20:42:09 [error] {"message":"400 - Unexpected token } in JSON at position 14"}
Jan-13-2023 20:42:09 [error] {"message":"400 - Unexpected token } in JSON at position 14"}
Jan-16-2023 15:07:12 [error] {"message":"400 - Unexpected token \n in JSON at position 33"}
Jan-16-2023 15:07:12 [error] {"message":"400 - Unexpected token \n in JSON at position 33"}
>>>>>>> da6afeaf85b20773743efe052a071fdf054b5f92
Jan-17-2023 15:50:44 [error] Error: {reference: validationMiddleware, message: name is required, errorCode: 412, errors: [], error: name is required} 
Jan-17-2023 15:50:57 [error] Error: {reference: validationMiddleware, message: password is required, errorCode: 412, errors: [], error: password is required} 
Jan-17-2023 15:51:10 [error] Error: {reference: changePassword, message: Current Password Incorrect, errorCode: 401, errors: [], error: Current Password Incorrect} 
Jan-18-2023 11:33:54 [error] Error: {reference: [object Object], message: Invalid Body!, errorCode: 500, errors: [], error: Invalid Body!} 
Jan-18-2023 11:35:33 [error] Error: {reference: [object Object], message: Invalid Body!, errorCode: 500, errors: [], error: Invalid Body!} 
Jan-18-2023 11:36:17 [error] Error: {reference: [object Object], message: Invalid Body!, errorCode: 500, errors: [], error: Invalid Body!} 
Jan-18-2023 11:36:55 [error] Error: {reference: [object Object], message: Invalid Body!, errorCode: 500, errors: [], error: Invalid Body!} 
Jan-18-2023 11:36:57 [error] Error: {reference: [object Object], message: Invalid Body!, errorCode: 500, errors: [], error: Invalid Body!} 
Jan-18-2023 11:39:10 [error] Error: {reference: [object Object], message: Invalid Body!, errorCode: 500, errors: [], error: Invalid Body!} 
Jan-18-2023 11:47:37 [error] Error: {reference: POST /user/signup, message: Server Error!, errorCode: 500, errors: [], error: signup is not defined} 
Jan-18-2023 11:49:28 [error] Error: {reference: POST /user/signup, message: Server Error!, errorCode: 500, errors: [], error: signup is not defined} 
Jan-18-2023 11:49:45 [error] Error: {reference: POST /user/signup, message: Server Error!, errorCode: 500, errors: [], error: signup is not defined} 
Jan-18-2023 11:50:45 [error] Error: {reference: POST /user/signup, message: Server Error!, errorCode: 500, errors: [], error: reference is not defined} 
Jan-18-2023 11:52:42 [error] Error: {reference: POST /user/signup, message: Server Error!, errorCode: 500, errors: [], error: signup is not defined} 
Jan-18-2023 11:55:47 [error] Error: {reference: POST /user/signup, message: Server Error!, errorCode: 500, errors: [], error: signUp is not defined} 
Jan-18-2023 12:03:44 [error] Error: {reference: async (req, res, next) => {
  
  try {
    const reference = signUp;
    let { name, email, password } = req.body;
   

    if (!email||!name||!password) {
      throw new AppError(reference,"fields is required", 400)
    }
   
    const user = await User.findOne({
      email: email,

    });

    if (user && user.isVerified) throw new AppError({ signup,"message": "User already registered with the same Email id!" });
    if (!user) {
      password = util.generateHash(password)
      await User.create({
        name, email, password
      })
     
    }
    //otp generate

    const otp = util.generateOtp();

    


    console.log(otp);
    const hashedOtp = util.generateHash(otp)
    console.log(hashedOtp);

    await TransientUser.findOneAndUpdate({ email: email}, {$set:{otpHash: hashedOtp }},{upsert:true}).then(update=>{
      const payload = { to: email,otp}
    sendGrid.sendEmail(payload)
    res.status(200).send({ message: "Otp send successfully!", otp });
    })
    
  } catch (error) {
  error.reference = error.reference ? error.reference : "POST /user/signup";

    next(error)
   
  }
}, message: fields is required, errorCode: 400, errors: [], error: fields is required} 
Jan-18-2023 12:04:11 [error] Error: {reference: POST /user/signup, message: Server Error!, errorCode: 500, errors: [], error: signup is not defined} 
Jan-18-2023 12:04:28 [error] Error: {reference: async (req, res, next) => {
  
  try {
    const reference = signUp;
    let { name, email, password } = req.body;
   

    if (!email||!name||!password) {
      throw new AppError(reference,"fields is required", 400)
    }
   
    const user = await User.findOne({
      email: email,

    });

    if (user && user.isVerified) throw new AppError({ signup,"message": "User already registered with the same Email id!" });
    if (!user) {
      password = util.generateHash(password)
      await User.create({
        name, email, password
      })
     
    }
    //otp generate

    const otp = util.generateOtp();

    


    console.log(otp);
    const hashedOtp = util.generateHash(otp)
    console.log(hashedOtp);

    await TransientUser.findOneAndUpdate({ email: email}, {$set:{otpHash: hashedOtp }},{upsert:true}).then(update=>{
      const payload = { to: email,otp}
    sendGrid.sendEmail(payload)
    res.status(200).send({ message: "Otp send successfully!", otp });
    })
    
  } catch (error) {
  error.reference = error.reference ? error.reference : "POST /user/signup";

    next(error)
   
  }
}, message: fields is required, errorCode: 400, errors: [], error: fields is required} 
Jan-18-2023 12:05:13 [error] Error: {reference: async (req, res, next) => {
  
  try {
    // const reference = signUp;
    let { name, email, password } = req.body;
   

    if (!email||!name||!password) {
      throw new AppError(signUp,"fields is required", 400)
    }
   
    const user = await User.findOne({
      email: email,

    });

    if (user && user.isVerified) throw new AppError({ signup,"message": "User already registered with the same Email id!" });
    if (!user) {
      password = util.generateHash(password)
      await User.create({
        name, email, password
      })
     
    }
    //otp generate

    const otp = util.generateOtp();

    


    console.log(otp);
    const hashedOtp = util.generateHash(otp)
    console.log(hashedOtp);

    await TransientUser.findOneAndUpdate({ email: email}, {$set:{otpHash: hashedOtp }},{upsert:true}).then(update=>{
      const payload = { to: email,otp}
    sendGrid.sendEmail(payload)
    res.status(200).send({ message: "Otp send successfully!", otp });
    })
    
  } catch (error) {
  error.reference = error.reference ? error.reference : "POST /user/signup";

    next(error)
   
  }
}, message: fields is required, errorCode: 400, errors: [], error: fields is required} 
Jan-18-2023 12:07:15 [error] Error: {reference: async (req, res, next) => {
  
  try {
  
    let { name, email, password } = req.body;
   

    if (!email||!name||!password) {
      throw new AppError(signUp,"fields is required", 400)
    }
   
    const user = await User.findOne({
      email: email,

    });

    if (user && user.isVerified) throw new AppError( signUp, "User already registered with the same Email id!" ,409);
    if (!user) {
      password = util.generateHash(password)
      await User.create({
        name, email, password
      })
     
    }
    //otp generate

    const otp = util.generateOtp();

    


    console.log(otp);
    const hashedOtp = util.generateHash(otp)
    console.log(hashedOtp);

    await TransientUser.findOneAndUpdate({ email: email}, {$set:{otpHash: hashedOtp }},{upsert:true}).then(update=>{
      const payload = { to: email,otp}
    sendGrid.sendEmail(payload)
    res.status(200).send({ message: "Otp send successfully!", otp });
    })
    
  } catch (error) {
  error.reference = error.reference ? error.reference : "POST /user/signup";

    next(error)
   
  }
}, message: User already registered with the same Email id!, errorCode: 409, errors: [], error: User already registered with the same Email id!} 
Jan-18-2023 12:20:14 [error] Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: signinUSer is not defined} 
Jan-18-2023 12:20:53 [error] Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: signinUser is not defined} 
Jan-18-2023 12:21:29 [error] Error: {reference: async (req, res,next) => {
  const { email, password } = req.body
  // const hashedEmail = util.generateHash(email)
  // console.log("HE -->  ",hashedEmail)
  try {
    const signInUser = await User.findOne({ email });
    console.log(signInUser);
  if (!signInUser || !util.compareHash(password, signInUser.password))
    throw new AppError(signIn,"Incorrect email or password",403 )
  if (!signInUser) {
    throw new AppError(signIn,"Invalid Email or Password", 401)
  } else {
    console.log(signInUser._id)
    res.send({
      token: util.generateToken({id:signInUser._id}),
      
    })
  }
    
  } catch (error) {
    // error.reference = error.reference ? error.reference : "POST /user/signIn";
    next(error)
  };
  
}, message: Incorrect email or password, errorCode: 403, errors: [], error: Incorrect email or password} 
Jan-18-2023 12:39:22 [error] Error: {reference: async (req, res,next) => {
  const { email, password } = req.body
  try{// const hashedEmail = util.generateHash(email)
  // console.log("HE -->  ",hashedEmail)
  
    const signInUser = await User.findOne({email:email});
    console.log(signInUser);
    // if (!signInUser) {
    //   throw new AppError(signIn,"Invalid Email or Password", 401)}
  if (!signInUser || !util.compareHash(password, signInUser.password))
    throw new AppError(signIn,"Incorrect email or password",403 )
   else {
    console.log(signInUser._id)
    res.send({
      token: util.generateToken({id:signInUser._id}),
    })
}}catch(error){
  next(error)
}
}, message: Incorrect email or password, errorCode: 403, errors: [], error: Incorrect email or password} 
Jan-18-2023 12:40:25 [error] Error: {reference: async (req, res,next) => {
  const { email, password } = req.body
  try{
    const signInUser = await User.findOne({email:email});
    console.log(signInUser);
    if (!signInUser) {
      throw new AppError(signIn,"Invalid Email or Password", 401)}
  if (!signInUser || !util.compareHash(password, signInUser.password))
    throw new AppError(signIn,"Incorrect email or password",403 )
   else {
    console.log(signInUser._id)
    res.send({
      token: util.generateToken({id:signInUser._id}),
    })
}}catch(error){
  next(error)
}
}, message: Invalid Email or Password, errorCode: 401, errors: [], error: Invalid Email or Password} 
Jan-18-2023 13:20:58 [error] Error: {reference: async (req, res, next) => {
  const { email, password } = req.body
  try {
    const signInUser = await User.findOne({ email: email });
    console.log(signInUser);
    if (!signInUser) {
      throw new AppError(signIn, "Invalid Email", 401)
    }
    if (!signInUser || !util.compareHash(password, signInUser.password))
      throw new AppError(signIn, "Incorrect email or password", 403)
    else {
      console.log(signInUser._id)
      res.send({
        token: util.generateToken({ id: signInUser._id }),
      })
    }
  } catch (error) {
    next(error)
  }
}, message: Invalid Email, errorCode: 401, errors: [], error: Invalid Email} 
Jan-18-2023 13:21:07 [error] Error: {reference: async (req, res, next) => {
  const { email, password } = req.body
  try {
    const signInUser = await User.findOne({ email: email });
    console.log(signInUser);
    if (!signInUser) {
      throw new AppError(signIn, "Invalid Email", 401)
    }
    if (!signInUser || !util.compareHash(password, signInUser.password))
      throw new AppError(signIn, "Incorrect email or password", 403)
    else {
      console.log(signInUser._id)
      res.send({
        token: util.generateToken({ id: signInUser._id }),
      })
    }
  } catch (error) {
    next(error)
  }
}, message: Incorrect email or password, errorCode: 403, errors: [], error: Incorrect email or password} 
Jan-18-2023 13:35:16 [error] Error: {reference: async (req, res, next) => {
  const { email, password } = req.body
  try {
    const signInUser = await User.findOne({ email: email });
    console.log(signInUser);
    if (!signInUser) {
      throw new AppError(signIn, "Invalid Email", 401)
    }
    if (!signInUser || !util.compareHash(password, signInUser.password))
      throw new AppError(signIn, "Incorrect email or password", 403)
    else {
      console.log(signInUser._id)
      res.send({
        token: util.generateToken({ id: signInUser._id }),
      })
    }
  } catch (error) {
    next(error)
  }
}, message: Incorrect email or password, errorCode: 403, errors: [], error: Incorrect email or password} 
Jan-18-2023 13:38:34 [error] Error: {reference: POST /user/verifyOtp, message: Server Error!, errorCode: 500, errors: [], error: Illegal arguments: string, undefined} 
Jan-18-2023 13:39:19 [error] Error: {reference: POST /user/verifyOtp, message: Server Error!, errorCode: 500, errors: [], error: Illegal arguments: string, undefined} 
Jan-18-2023 13:39:21 [error] Error: {reference: POST /user/verifyOtp, message: Server Error!, errorCode: 500, errors: [], error: Illegal arguments: string, undefined} 
Jan-18-2023 13:41:31 [error] Error: {reference: POST /user/verifyOtp, message: Server Error!, errorCode: 500, errors: [], error: Illegal arguments: string, undefined} 
Jan-18-2023 13:42:36 [error] Error: {reference: async (req, res,next) => {
  try {
    let { email, otp } = req.body;


    console.log("email", email, "otpHash", otp)

    const transientUser = await TransientUser.findOne({ email })
      // .then(async transientUser => {
        console.log("transientUser", transientUser);
        // console.log("!util.compareHash(otpHash, transientUser.otp)",!util.compareHash(otp, transientUser.otpHash));
        if (!transientUser || !util.compareHash(otp, transientUser.otpHash)) throw new AppError(verifyOtp, "incorrect otp", 401)



        const transientUsers = await TransientUser.findOneAndDelete({ email: email })
        if (transientUsers) {
          let user = await User.findOneAndUpdate({ email }, { $set: { isVerified: true } }, { new: true })
          if (user) {
            const uuserId = uuidv4();
            let user2 = await User.findOneAndUpdate({ email }, { $set: { userId: uuserId } }, { upsert: true })
            if (user2) {
              console.log(user2, "user");
              if (user2 && user2.isVerified) {
                return res.status(200).send({ "message": "otp verified successfully" })
              }

              throw new AppError(verifyOtp, "something went wrong please try again", 400)
            }
          }
        }

        // return TransientUser.findOneAndDelete({ email: email }).then(value => {
        //   return User.findOneAndUpdate({ email }, { $set: { isVerified: true } }, { new: true })
        // }).then(data => {
        //   const uuserId = uuidv4();
        //   return User.findOneAndUpdate({ email }, { $set: { userId: uuserId } }, { upsert: true })
        // })

        //   .then(user => {
        //     console.log(user, "user");
        //     if (user && user.isVerified)
        //       return res.status(200).send({ "message": "otp verified successfully" })

        //     throw new AppError(verifyOtp, "something went wrong please try again", 400)

        //   })
        //   .catch(error)

      }
  catch (error) {
    error.reference = error.reference ? error.reference : "POST /user/verifyOtp";
    next(error);
  }


}, message: incorrect otp, errorCode: 401, errors: [], error: incorrect otp} 
Jan-18-2023 13:47:41 [error] Error: {reference: async (req, res, next) => {
  try {
    let { email, otp } = req.body;


    console.log("email", email, "otpHash", otp)

    const transientUser = await TransientUser.findOne({ email })
    // .then(async transientUser => {
    console.log("transientUser", transientUser);
    // console.log("!util.compareHash(otpHash, transientUser.otp)",!util.compareHash(otp, transientUser.otpHash));
    if (!transientUser || !util.compareHash(otp, transientUser.otpHash)) throw new AppError(verifyOtp, "incorrect otp", 401)



    const transientUsers = await TransientUser.findOneAndDelete({ email: email })
    if (transientUsers) {
      let user = await User.findOneAndUpdate({ email }, { $set: { isVerified: true } }, { new: true })
      if (user) {
        const uuserId = uuidv4();
        let user2 = await User.findOneAndUpdate({ email }, { $set: { userId: uuserId } }, { upsert: true })
        if (user2) {
          console.log(user2, "user");
          if (user2 && user2.isVerified) {
            return res.status(200).send({ "message": "otp verified successfully" })
          }

          throw new AppError(verifyOtp, "something went wrong please try again", 400)
        }
      }
    }

  }
  catch (error) {
    error.reference = error.reference ? error.reference : "POST /user/verifyOtp";
    next(error);
  }


}, message: incorrect otp, errorCode: 401, errors: [], error: incorrect otp} 
Jan-18-2023 15:20:12 [error] Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: Query was already executed: User.findOne({ email: 'sunayraufdftela08@gmail.com' })} 
Jan-18-2023 15:21:31 [error] Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: Query was already executed: User.findOne({ email: 'sunayraufdftela08@gmail.com' })} 
Jan-18-2023 15:22:32 [error] Error: {reference: POST /user/forgotPassword, message: Server Error!, errorCode: 500, errors: [], error: Query was already executed: User.findOne({ email: 'sunayraufdftela08@gmail.com' })} 
Jan-18-2023 15:23:53 [error] Error: {reference: POST /user/forgotPassword, message: Server Error!, errorCode: 500, errors: [], error: Query was already executed: User.findOne({ email: 'sunayraufdftela08@gmail.com' })} 
Jan-18-2023 15:23:54 [error] Error: {reference: POST /user/forgotPassword, message: Server Error!, errorCode: 500, errors: [], error: Query was already executed: User.findOne({ email: 'sunayraufdftela08@gmail.com' })} 
Jan-18-2023 15:26:53 [error] Error: {reference: POST /user/forgotPassword, message: Server Error!, errorCode: 500, errors: [], error: Query was already executed: User.findOne({ email: 'sunayraufdftela08@gmail.com' })} 
Jan-18-2023 15:26:54 [error] Error: {reference: POST /user/forgotPassword, message: Server Error!, errorCode: 500, errors: [], error: Query was already executed: User.findOne({ email: 'sunayraufdftela08@gmail.com' })} 
Jan-18-2023 15:51:56 [error] Error: {reference: async (req, res, next) => {
  const { email, password } = req.body
  try {
    const signInUser = await User.findOne({ email: email });
    console.log(signInUser);
    if (!signInUser) {
      throw new AppError(signIn, "Invalid Email", 401)
    }
    if (!signInUser || !util.compareHash(password, signInUser.password))
      throw new AppError(signIn, "Incorrect email or password", 403)
    else {
      console.log(signInUser._id)
      res.send({
        token: util.generateToken({ id: signInUser._id }),
      })
    }
  } catch (error) {
    next(error)
  }
}, message: Incorrect email or password, errorCode: 403, errors: [], error: Incorrect email or password} 
Jan-18-2023 15:55:45 [error] Error: {reference: async (req, res,next) => {
  const { email } = req.body;
try {
  const user=  await User.findOne({ email: email })
  // console.log(user);
  if(!user){
    throw new AppError(forgetPassword,"User not found",401);
  }
  if(user){
    const resetToken = crypto.randomBytes(20).toString("hex");
    user.resetPasswordToken = resetToken;
    user.resetPasswordExpires = Date.now() + 3600000; // expires in 1 hour
    await user.save()
    const payload = { to: email, resetToken: resetToken, subject: "verification Email" }
        sendGrid.sendEmailForResetPassword(payload)
        res.status(200).send({ message: "Link send successfully!" });
  }
  
} catch (error) {
  next(error);
}

    // if (err) {
    //   res.status(500).json({ message: err });
    // } else if (!user) {
    //   throw new AppError(forgetPassword,"User not found",401);
    // } else {
      // // Generate and set a password reset token
      // const resetToken = crypto.randomBytes(20).toString("hex");
      // user.resetPasswordToken = resetToken;
      // user.resetPasswordExpires = Date.now() + 3600000; // expires in 1 hour
      // user.save((err) => {
      //   if (err) {
      //     res.status(500).json({ message: err });
      //   } else {
      //     // Send the password reset email
      //     const payload = { to: email, resetToken: resetToken, subject: "verification Email" }
      //     sendGrid.sendEmailForResetPassword(payload)
      //     res.status(200).send({ message: "Link send successfully!" });


      //   }
      // }
      // );
      // await user.save()
      // const payload = { to: email, resetToken: resetToken, subject: "verification Email" }
      //     sendGrid.sendEmailForResetPassword(payload)
      //     res.status(200).send({ message: "Link send successfully!" });

    
  }, message: User not found, errorCode: 401, errors: [], error: User not found} 
Jan-18-2023 15:57:43 [error] Error: {reference: async (req, res, next) => {
  const { email } = req.body;
  try {
    const user = await User.findOne({ email: email })
    // console.log(user);
    if (!user) {
      throw new AppError(forgetPassword, "User not found", 401);
    }
    if (user) {
      const resetToken = crypto.randomBytes(20).toString("hex");
      user.resetPasswordToken = resetToken;
      user.resetPasswordExpires = Date.now() + 3600000; // expires in 1 hour
      await user.save()
      const payload = { to: email, resetToken: resetToken, subject: "verification Email" }
      sendGrid.sendEmailForResetPassword(payload)
      res.status(200).send({ message: "Link send successfully!" });
    }

  } catch (error) {
    next(error);
  }
}, message: User not found, errorCode: 401, errors: [], error: User not found} 
Jan-18-2023 15:59:32 [error] Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: Query was already executed: User.findOne({ resetPasswordToken: 'a3d1d9147a5ed197940ac271...} 
Jan-18-2023 16:03:36 [error] Error: {reference: async (req, res,next) => {
  const { password } = req.body;

  let { token } = req.params;
  // console.log(User);
  // console.log(token);
  try {
  const user = await User.findOne({ resetPasswordToken: token })
  if (!user) {
        throw new AppError( resetPassword,"Password reset token is invalid or has expired.",401);
      } else {
        user.password = util.generateHash(password);
        user.resetPasswordToken = undefined;
        user.resetPasswordExpires = undefined;
        user.save((err) => {
          if (err) {
            res.status(500).json({ message: err });
          } else {
            res.status(200).json({ message: "Password reset successful." });
          }
        });
  
      }
    }
    
  catch (error) {
    next(error);
  }
  
}, message: Password reset token is invalid or has expired., errorCode: 401, errors: [], error: Password reset token is invalid or has expired.} 
Jan-18-2023 16:25:11 [error] Error: {reference: async (req, res, next) => {
  const { email, password } = req.body
  try {
    const signInUser = await User.findOne({ email: email });
    console.log(signInUser);
    if (!signInUser) {
      throw new AppError(signIn, "Invalid Email", 401)
    }
    if (!signInUser || !util.compareHash(password, signInUser.password))
      throw new AppError(signIn, "Incorrect email or password", 403)
    else {
      console.log(signInUser._id)
      res.send({
        token: util.generateToken({ id: signInUser._id }),
      })
    }
  } catch (error) {
    next(error)
  }
}, message: Incorrect email or password, errorCode: 403, errors: [], error: Incorrect email or password} 
Jan-18-2023 16:26:09 [error] Error: {reference: async (req, res, next) => {
  const { email, password } = req.body
  try {
    const signInUser = await User.findOne({ email: email });
    console.log(signInUser);
    if (!signInUser) {
      throw new AppError(signIn, "Invalid Email", 401)
    }
    if (!signInUser || !util.compareHash(password, signInUser.password))
      throw new AppError(signIn, "Incorrect email or password", 403)
    else {
      console.log(signInUser._id)
      res.send({
        token: util.generateToken({ id: signInUser._id }),
      })
    }
  } catch (error) {
    next(error)
  }
}, message: Incorrect email or password, errorCode: 403, errors: [], error: Incorrect email or password} 
Jan-18-2023 16:26:20 [error] Error: {reference: async (req, res, next) => {

  try {

    let { name, email, password } = req.body;


    if (!email || !name || !password) {
      throw new AppError(signUp, "fields is required", 400)
    }

    const user = await User.findOne({
      email: email,

    });

    if (user && user.isVerified) throw new AppError(signUp, "User already registered with the same Email id!", 409);
    if (!user) {
      password = util.generateHash(password)
      await User.create({
        name, email, password
      })

    }
    //otp generate

    const otp = util.generateOtp();




    console.log(otp);
    const hashedOtp = util.generateHash(otp)
    console.log(hashedOtp);

    await TransientUser.findOneAndUpdate({ email: email }, { $set: { otpHash: hashedOtp } }, { upsert: true }).then(update => {
      const payload = { to: email, otp }
      sendGrid.sendEmail(payload)
      res.status(200).send({ message: "Otp send successfully!", otp });
    })

  } catch (error) {
    error.reference = error.reference ? error.reference : "POST /user/signup";

    next(error)

  }
}, message: User already registered with the same Email id!, errorCode: 409, errors: [], error: User already registered with the same Email id!} 
Jan-18-2023 16:34:16 [error] Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: Unexpected token } in JSON at position 51} 
Jan-18-2023 16:34:20 [error] Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: Cannot read property 'id' of undefined} 
Jan-18-2023 16:34:22 [error] Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: Cannot read property 'id' of undefined} 
Jan-18-2023 16:42:27 [error] Error: {reference: Anonymous, message: Server Error!, errorCode: 500, errors: [], error: Unexpected token } in JSON at position 52} 
Jan-18-2023 17:01:43 [error] Error: {reference: async (req, res,next) => {
    // const sellerId = req.decodedToken.id
  try {
    const { productId ,categoryName} = req.body;
    const categoryFound = await CategoryModel.findOne({categoryName})
    if(categoryFound){
        throw new AppError(addCategory,"category already exist",409)
    }
    CategoryModel.create({ categoryName,
        productId })
        .then(result => {
            res.status(201).send({ message: "Category added Successfully", result: "result" })
        })
        .catch(err => {
            res.status(400).send({ message: "Failed", error: err })
        })
  } catch (error) {
    next(error);
  }
    
}, message: category already exist, errorCode: 409, errors: [], error: category already exist} 
Jan-18-2023 17:03:16 [error] Error: {reference: async (req, res,next) => {
    // const sellerId = req.decodedToken.id
  try {
    const { productId ,categoryName} = req.body;
    const categoryFound = await CategoryModel.findOne({categoryName})
    if(categoryFound){
        throw new AppError(addCategory,"category already exist",409)
    }
    CategoryModel.create({ categoryName,
        productId })
        .then(result => {
            res.status(201).send({ message: "Category added Successfully", result: "result" })
        })
        .catch(err => {
          throw new AppError(addCategory,"Failed",424)
        })
  } catch (error) {
    next(error);
  }
    
}, message: category already exist, errorCode: 409, errors: [], error: category already exist} 
Jan-18-2023 17:03:17 [error] Error: {reference: async (req, res,next) => {
    // const sellerId = req.decodedToken.id
  try {
    const { productId ,categoryName} = req.body;
    const categoryFound = await CategoryModel.findOne({categoryName})
    if(categoryFound){
        throw new AppError(addCategory,"category already exist",409)
    }
    CategoryModel.create({ categoryName,
        productId })
        .then(result => {
            res.status(201).send({ message: "Category added Successfully", result: "result" })
        })
        .catch(err => {
          throw new AppError(addCategory,"Failed",424)
        })
  } catch (error) {
    next(error);
  }
    
}, message: category already exist, errorCode: 409, errors: [], error: category already exist} 
Jan-18-2023 17:03:24 [error] Error: {reference: async (req, res,next) => {
    // const sellerId = req.decodedToken.id
  try {
    const { productId ,categoryName} = req.body;
    const categoryFound = await CategoryModel.findOne({categoryName})
    if(categoryFound){
        throw new AppError(addCategory,"category already exist",409)
    }
    CategoryModel.create({ categoryName,
        productId })
        .then(result => {
            res.status(201).send({ message: "Category added Successfully", result: "result" })
        })
        .catch(err => {
          throw new AppError(addCategory,"Failed",424)
        })
  } catch (error) {
    next(error);
  }
    
}, message: category already exist, errorCode: 409, errors: [], error: category already exist} 
Jan-18-2023 17:20:36 [error] Error: {reference: async (req, res, next) => {

  try {

    let { name, email, password } = req.body;


    if (!email || !name || !password) {
      throw new AppError(signUp, "fields is required", 400)
    }

    const user = await User.findOne({
      email: email,

    });

    if (user && user.isVerified) throw new AppError(signUp, "User already registered with the same Email id!", 409);
    if (!user) {
      password = util.generateHash(password)
      await User.create({
        name, email, password
      })

    }
    //otp generate

    const otp = util.generateOtp();




    console.log(otp);
    const hashedOtp = util.generateHash(otp)
    console.log(hashedOtp);

    await TransientUser.findOneAndUpdate({ email: email }, { $set: { otpHash: hashedOtp } }, { upsert: true }).then(update => {
      const payload = { to: email, otp }
      sendGrid.sendEmail(payload)
      res.status(200).send({ message: "Otp send successfully!", otp });
    })

  } catch (error) {
    error.reference = error.reference ? error.reference : "POST /user/signup";

    next(error)

  }
}, message: fields is required, errorCode: 400, errors: [], error: fields is required} 
Jan-18-2023 17:21:13 [error] Error: {reference: signUp, message: fields is required, errorCode: 400, errors: [], error: fields is required} 
